const mongoose = require('mongoose');

const crypto = require('crypto')
const { v4 } = require('uuid')
const fs = require('fs')



peerID = process.argv[2]

// === schema definitions ===

/**
 * client txn structure (will be stored in txn pools)
 * 
 * {
 *  * id: // generated by receiving node -> propagated through the network
 *  btxn:{
 *      id:
 *      origin: (which txn id was spent to create this)
 *      pubKey: public key
 *      amount:
 *      spent:
 * }
 * 
 * amount: amount to transfer
 * rpubKey: receiver public key 
 * signature: signed by sender (bxtn||rpubKey||amount)
 * 
 * --- or ---
 * 
 * tstamp: from CBDC
 * signature: (bxtn||tstamp) -> signed by cbdc
 * }
 * 
 * only btxn will stored in the txn database
 */

const TxnSchema = new mongoose.Schema({
    id: {
        type: String,
        required: true
    },
    origin: {
        type: String,
        required: true
    },
    pubKey: {
        type: String,
        required: true
    },
    amount: {
        type: Number,
        required: true
    },
    spent: {
        type: Boolean,
        required: true
    }
},
    {
        timestamps: false,
        versionKey: false,
    })

const Txn = mongoose.model(`txns${peerID}`, TxnSchema, `txns${peerID}`)

/**
 * structure of a block
 * 
 * {
 * id - height of block
 * merkleRoot: (will be 010 if block generated was invalid)
 * transactions:[]
 * prevHash:
 * hash: (id||merkleRoot||prevHash||tstamp)
 * committer: will be id
 * signature: hash will be signed
 * tstamp:
 * endorsers (block validators - those who have signed yes on the block):[{
 *  id: 
 *   signature: id || hash || "yes"
 * }]
 * }
 */

const BlockChainSchema = new mongoose.Schema({
    id: {
        type: Number,
        required: true
    },
    merkleRoot: {
        type: String,
        required: true
    },
    transactions: [{
        id: {
            type: String,
            required: true
        },
        origin: {
            type: String,
            required: true
        },
        pubKey: {
            type: String,
            required: true
        },
        amount: {
            type: Number,
            required: true
        },
        spent: {
            type: Boolean,
            required: true
        }
    }],
    tstamp: {
        type: String,
        required: true
    },
    prevHash: {
        type: String,
        required: true
    },
    hash: {
        type: String,
        required: true
    },
    committer: {
        type: 'Number',
        required: true
    },
    signature: {
        type: String,
        required: true
    },
    endorsers: [
        {
            id: {
                type: String,
                required: true
            },
            signature: {
                type: String,
                required: true
            }
        }
    ]
}, {
    timestamps: false,
    versionKey: false
})

const Chain = mongoose.model(`chain${peerID}`, BlockChainSchema, `chain${peerID}`)

// === schema definitions ===

// ==== db utilities === //

/**
 * @description
 * will update the database that contains transactions (contains used and unused)
 * will also update the stakes of the various peers
 * @param {Array} transactions all transactions id
 */
const updateTransDB = async (transactions) => {
    // update with spent and unspent transactions
    for (let txn of transactions) {
        if (txn.spent) {
            let check = await Txn.find({ id: txn.id })

            if (check.length == 0) {
                var ntxn = new Txn()
                ntxn.id = txn.id
                ntxn.pubKey = txn.pubKey
                ntxn.amount = txn.amount
                ntxn.origin = txn.origin
                ntxn.spent = true
                console.log(`new transaction added to db ${JSON.stringify(txn)} -- ${Date()}`)
                await ntxn.save()

            }

            if (check[0].spent == false) {
                await Txn.findOneAndUpdate({ id: txn.id }, {
                    $set: { spent: true }
                })
            }

            console.log(`new transaction added to db ${JSON.stringify(txn)} -- ${Date()}`)


        } else {
            var ntxn = new Txn();
            ntxn.id = txn.id
            ntxn.pubKey = txn.pubKey
            ntxn.amount = txn.amount
            ntxn.origin = txn.origin
            ntxn.spent = false
            console.log(`new transaction added to db ${JSON.stringify(txn)} -- ${Date()}`)
            await ntxn.save()
        }
    }
}

/**
 * @description
 * will update their copy of the blockchain on the database
 */
const addToBlockChainDB = async (block) => {
    // update database with new blockchain
    await updateTransDB(block.transactions)
    const newB = new Chain()
    for (let i in block) {
        newB[i] = block[i]
    }
    await newB.save()
    console.log(`added new block to database ${JSON.stringify(block)} -- ${Date()}`)
}

/**
 * @description
 * check if database has transaction that is unspent
 * -> false > txn has been spend
 * -> true > txn is defined and not spent
 * -> txn > is undefined
 */
const isTxnValidInTxnDB = async (txn) => {
    const txns = await Txn.find({ id: txn.id, pubKey: txn.pubKey })

    if (txns.length == 1 && txns[0].spent == true) {
        return false
    } else {
        return txns.length == 1 ? true : undefined
    }
}

/**
 * get last 10 blocks in the blockchain
 */

const getLast10Blocks = async () => {
    const last10Blocks = await Chain.find().sort({ id: -1 }).limit(10).select("-_id")
    return last10Blocks
}

/**
 * get last blocks in the blockchain
 */

const getLastBlock = async () => {

    const lastBlock = await Chain.find({}).sort({ id: -1 }).limit(1).select("-_id")
    console.log(lastBlock)

    return lastBlock[0]
}


/**
 * to get blocks from a certain height
 */
const getBlocksFromH = async (h) => {
    const blocks = await Chain.find({ id: { $gt: h } }).sort({ id: 1 })
    return blocks
}

/**
 * to get txns of a certan user
 */

const getTxns = async (pubKey) => {
    const txns = await Txn.find({ pubKey, spent: false }).select("-_id")
    return txns;
}

const saveCTxnToP2P = async (txn, nid) => {

    const signature = Buffer.from(txn.signature, 'base64')

    let tst = JSON.stringify(txn.btxn)
    tst += txn.tstamp

    let data = Buffer.from(tst)
    const pubKey = fs.readFileSync(`${__dirname}/cbdc_pub.pem`).toString()

    const isValid = crypto.verify('sha256', data, pubKey, signature)

    if (isValid) {

        txn.btxn.origin = `cbdc - ${txn.btxn.id}`
        txn.btxn.id = nid
        const ntxn = new Txn();

        for (let i in txn.btxn) {
            ntxn[i] = txn.btxn[i]
        }

        ntxn.spent = false

        await ntxn.save()
    }

}

const txnP2P_TO_C = async (id) => {
    console.log("inside txnpp2p_to_c")

    const privateKey = fs.readFileSync(`${__dirname}/${peerID}/wallet/privateKey.pem`).toString()

    await Txn.findOneAndUpdate({ id }, { $set: { spent: true } })

    const txn = await Txn.findOne({ id }).select("-_id")
    console.log(txn)

    let tstamp = Date.now().toString()
    let sig_msg = JSON.stringify(txn)
    sig_msg += tstamp

    let signature = crypto.sign('sha256', Buffer.from(sig_msg), privateKey).toString('base64')

    return {
        btxn: txn,
        signature,
        tstamp,
        id: peerID
    }
}


const connectToDB = async () => {
    await mongoose.connect('mongodb+srv://pos_node:pos_node@g0-cluster.4szx0.mongodb.net/pos_bk_db?retryWrites=true&w=majority')
}


module.exports = {
    connectToDB,
    updateTransDB,
    addToBlockChainDB,
    isTxnValidInTxnDB,
    getLast10Blocks,
    getLastBlock,
    getTxns,
    saveCTxnToP2P,
    txnP2P_TO_C
}