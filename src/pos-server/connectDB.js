const mongoose = require('mongoose');
peerID = process.argv[2]

// === schema definitions ===

/**
 * client txn structure (will be stored in txn pools)
 * 
 * {
 *  * id: // generated by receiving node -> propagated through the network
 *  btxn:{
 *      id:
 *      origin: (which txn id was spent to create this)
 *      pubKey: public key
 *      amount:
 *      spent:
 * }
 * amount: amount to transfer
 * rpubKey: receiver public key 
 * tstamp: from CBDC
 * signature: (bxtn||tstamp) -> signed by cbdc
 * signature2: signed by sender (bxtn||rpubKey||amount)
 * }
 * 
 * only btxn will stored in the txn database
 */

const TxnSchema = new mongoose.Schema({
    id: {
        type: String,
        required: true
    },
    origin: {
        type: String,
        required: true
    },
    pubKey: {
        type: String,
        required: true
    },
    amount: {
        type: Number,
        required: true
    },
    spent: {
        type: Boolean,
        required: true
    }
},
    {
        timestamps: true,
    })

const Txn = mongoose.model(`txns${peerID}`, TxnSchema, `txns${peerID}`)

/**
 * structure of a block
 * 
 * {
 * id - height of block
 * merkleRoot: (will be 010 if block generated was invalid)
 * transactions:[]
 * prevHash:
 * hash: (id||merkleRoot||prevHash||tstamp)
 * committer: will be id
 * signature: hash will be signed
 * tstamp:
 * endorsers (block validators - those who have signed yes on the block):[{
 *  id: 
 *   signature: id || hash || "yes"
 * }]
 * }
 */

const BlockChainSchema = new mongoose.Schema({
    id: {
        type: Number,
        required: true
    },
    merkleRoot: {
        type: String,
        required: true
    },
    transactions: [{
        id: {
            type: String,
            required: true
        },
        origin: {
            type: String,
            required: true
        },
        pubKey: {
            type: String,
            required: true
        },
        amount: {
            type: Number,
            required: true
        },
        spent: {
            type: Boolean,
            required: true
        }
    }],
    tstamp: {
        type: String,
        required: true
    },
    prevHash: {
        type: String,
        required: true
    },
    hash: {
        type: String,
        required: true
    },
    committer: {
        type: 'Number',
        required: true
    },
    signature: {
        type: String,
        required: true
    },
    endorsers: [
        {
            id: {
                type: String,
                required: true
            },
            signature: {
                type: String,
                required: true
            }
        }
    ]
}, {
    timestamps: true,
})

const Chain = mongoose.model(`chain${peerID}`, BlockChainSchema, `chain${peerID}`)

// === schema definitions ===

// ==== db utilities === //

/**
 * @description
 * will update the database that contains transactions (contains used and unused)
 * will also update the stakes of the various peers
 * @param {Array} transactions all transactions id
 */
const updateTransDB = async (transactions) => {
    // update with spent and unspent transactions
    for (let txn of transactions) {
        if (txn.spent) {
            let check = await Txn.find({ id: txn.id })

            if (check.length == 0) {
                var ntxn = new Txn()
                ntxn.id = txn.id
                ntxn.pubKey = txn.pubKey
                ntxn.amount = txn.amount
                ntxn.origin = txn.origin
                ntxn.spent = true
                console.log(`new transaction added to db ${JSON.stringify(txn)} -- ${Date()}`)
                await ntxn.save()

            }

            if (check[0].spent == false) {
                await Txn.findOneAndUpdate({ id: txn.id }, {
                    $set: { spent: true }
                })
            }

            console.log(`new transaction added to db ${JSON.stringify(txn)} -- ${Date()}`)


        } else {
            var ntxn = new Txn();
            ntxn.id = txn.id
            ntxn.pubKey = txn.pubKey
            ntxn.amount = txn.amount
            ntxn.origin = txn.origin
            ntxn.spent = false
            console.log(`new transaction added to db ${JSON.stringify(txn)} -- ${Date()}`)
            await ntxn.save()
        }
    }
}

/**
 * @description
 * will update their copy of the blockchain on the database
 */
const addToBlockChainDB = async (block) => {
    // update database with new blockchain
    await updateTransDB(block.transactions)
    const newB = new Chain()
    for (let i in block) {
        newB[i] = block[i]
    }
    await newB.save()
    console.log(`added new block to database ${JSON.stringify(block)} -- ${Date()}`)
}

/**
 * @description
 * check if database has transaction that is unspent
 * -> false > txn has been spend
 * -> true > txn is defined and not spent
 * -> txn > is undefined
 */
const isTxnValidInTxnDB = async (txn) => {
    const txns = await Txn.find(txn.id)
    if (txns.length == 1 && txn.spend == true) {
        return false
    } else {
        return txns.length == 1 ? true : undefined
    }
}

/**
 * get last block in the blockchain
 */

const getLastBlock = async () => {
    const lastBlock = await Chain.find().sort({ id: -1 }).limit(1)
    console.log(`last block received ${lastBlock}`)
    return lastBlock[0]
}

/**
 * to get blocks from a certain height
 */
const getBlocksFromH = async (h) => {
    const blocks = await Chain.find({ id: { $gt: h } }).sort({ id: 1 })
    return blocks
}

/**
 * to get txns of a certan user
 */

const getTxns = async (pubKey) => {
    const txns = await Txn.find({ pubKey, spent: false })
    return txns;
}


const connectToDB = async () => {
    await mongoose.connect('mongodb+srv://pos_node:pos_node@g0-cluster.4szx0.mongodb.net/pos_bk_db?retryWrites=true&w=majority')
}


module.exports = {
    connectToDB,
    updateTransDB,
    addToBlockChainDB,
    isTxnValidInTxnDB,
    getLastBlock,
    getBlocksFromH,
    getTxns
}